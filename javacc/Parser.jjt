options {
    LOOKAHEAD=1;
//    ERROR_REPORTING=true;
//    DEBUG_LOOKAHEAD = true;
//    DEBUG_PARSER = true;
    MULTI=true;
    BUILD_NODE_FILES=false;
}
PARSER_BEGIN(Parser)

import java.lang.System;
import java.util.ArrayList;

public class Parser {
    public static int err_counter = 0;
    public static int MAX_ERRORS = 10;
    
    public static ArrayList<String> getExpectedTokens(ParseException e){
        ArrayList<String> tokens = new ArrayList<String>();
        for(int i = 0; i < e.expectedTokenSequences.length; i++){
            for(int j = 0; j < e.expectedTokenSequences[i].length; j++){
                tokens.add(tokenImage[e.expectedTokenSequences[i][j]]);
            }
        }
        return tokens;
    }

    public void SkipTo(int kind, String errType) {
        ParseException e = generateParseException();
        boolean isEOF = false;
        Token token = getToken(0);
        Token t;
        do {
          t = getNextToken();
          if(t.kind == EOF){
            isEOF = true;
            break;
          }
        } while (t.kind != kind);

        System.out.println(MyUtils.ANSI_RED + "ERROR" + MyUtils.ANSI_YELLOW + " " + errType + MyUtils.ANSI_RESET);

        if(isEOF)
            System.out.println("\tMissing"  + MyUtils.ANSI_CYAN +  " '{'" + MyUtils.ANSI_RESET +  " at"  + MyUtils.ANSI_CYAN + " line " + String.valueOf(token.beginLine) + MyUtils.ANSI_RESET);
        else{
            System.out.println("\tFound " + MyUtils.ANSI_CYAN + "\"" + t.image + "\""  + MyUtils.ANSI_RESET +  " at " + MyUtils.ANSI_CYAN + "line " + String.valueOf(t.beginLine) + ", column " + String.valueOf(t.beginColumn) + MyUtils.ANSI_RESET + ".");
            System.out.print("\tExpected one of: ");
            for(int i = 0; i < getExpectedTokens(e).size() - 1; i++)
                System.out.print(getExpectedTokens(e).get(i) + ", ");
            System.out.println(getExpectedTokens(e).get(getExpectedTokens(e).size() - 1));
        }
        System.out.println();
        err_counter++;
        if(err_counter == MAX_ERRORS){
            System.out.println(MyUtils.ANSI_RED + "Aborted after " + MAX_ERRORS + " errors." + MyUtils.ANSI_RESET);
            System.exit(0);
        }
      }
}
PARSER_END(Parser)


SKIP:
{
      " " | "\r" | "\t" | "\n"
    | < SINGLE_LINE : "//"  (~["\n"])* "\n" >
    | < MULTIPLE_LINE : "/*" ( ~["*"] | ("*" ~["/"]) )* "*/" >
}

TOKEN:
{
    /* Primitives */
      < TRUE        : "true"            >
    | < FALSE       : "false"           >
    | < BOOLEAN     : "boolean"         >
    | < INT         : "int"             >
    | < VOID        : "void"            >
    | < STRING      : "String"          >
    /* Keywords and characters */
    | < THIS        : "this"            >
    | < NEW         : "new"             >
    | < LPARENS     : "("               >
    | < RPARENS     : ")"               >
    | < LSQPARENS   : "["               >
    | < RSQPARENS   : "]"               >
    | < DOT         : "."               >
    | < LBRACKET    : "{"               >
    | < RBRACKET    : "}"               >
    | < SEMICOLON   : ";"               >
    | < COMMA       : ","               >
    | < LENGTH      : "length"          >
    | < IMPORT      : "import"          >
    | < CLASS       : "class"           >
    | < EXTENDS     : "extends"         >
    | < METHOD      : "method"          >
    | < PUBLIC      : "public"          >
    | < RETURN      : "return"          >
    | < IF          : "if"              >
    | < ELSE        : "else"            >
    | < WHILE       : "while"           >
    | < STATIC      : "static"          >
    | < MAIN        : "main"            >
    /* Operators */
    | < NOT         : "!"               >
    | < AND         : "&&"              >
    | < LESSTHAN    : "<"               >
    | < PLUS        : "+"               >
    | < MINUS       : "-"               >
    | < TIMES       : "*"               >
    | < DIVIDOR     : "/"               >
    | < EQUALS      : "="               >
    /* Literals */
    | < INTEGER_LITERAL : (<DIGIT>)+    >   
    /* Identifiers */
    | < IDENTIFIER  : (<LETTER> | "_" | "$")
        ( <LETTER> | "_" | <DIGIT> )*   >
    | < DIGIT       : (["0" -"9"])      >
    | < LETTER      : ["a"-"z", "A"-"Z"]>
}

SimpleNode Start(): {}
{
    (ImportDeclaration())* ClassDeclaration() <EOF> {
        return jjtThis;
    }
}

void ImportDeclaration() #ImportDeclaration: {Token name; String argument, returnType; } 
{
    <IMPORT>
    /* Static is optional */
    [<STATIC> {jjtThis.setStatic();}]
    /* Grab full function name and store it*/
    name=<IDENTIFIER> {jjtThis.buildMethodName(name.image);}
    //Multiple class espefiers, last one will be function name
    (<DOT> name=<IDENTIFIER> { jjtThis.buildMethodName(name.image); } )*
    /* Store all arguments' info */
    [<LPARENS> [argument=Type() { jjtThis.addArgument(argument); } (<COMMA> argument=Type() {jjtThis.addArgument(argument);} )*
        | <VOID>] <RPARENS>]
    /* Store optional return type*/
    [returnType=Type() {jjtThis.setReturnType(returnType);} | <VOID>] //Default in node is already set to void
    <SEMICOLON>
}

void ClassDeclaration() #ClassDeclaration: {Token classId,extendsId;} 
{
    <CLASS> classId=<IDENTIFIER> { jjtThis.classId = classId.image; } [ <EXTENDS> extendsId=<IDENTIFIER> { jjtThis.extendsId = extendsId.image; } ] <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (FunctionDeclaration())*
    <RBRACKET>
}

void VarDeclaration() #VarDeclaration: {Token varId;String type;}
{
    type=Type() { jjtThis.type=type; } varId=<IDENTIFIER> { jjtThis.varId = varId.image; } <SEMICOLON>
}

void FunctionDeclaration() #void: {}
{
    <PUBLIC> (
        MethodDeclaration()
        | MainDeclaration()
    )
}

void MethodDeclaration() #MethodDeclaration: {Token methodId, argName; String argType, returnType;}
{
    /* Store function return type*/
    returnType=Type() {jjtThis.setReturnType(returnType);}
    /* Store function name */
    methodId=<IDENTIFIER>  {jjtThis.buildMethodName(methodId.image);}
    <LPARENS>
    /* Store arguments' type and name */
    [ argType=Type() argName=<IDENTIFIER> {jjtThis.addArgument(argType, argName.image);}
        ( <COMMA> argType=Type() argName=<IDENTIFIER> {jjtThis.addArgument(argType, argName.image);} )* ]
    <RPARENS> <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    Return() <RBRACKET>
}

void Return() #Return: {}
{
    <RETURN> Expression() <SEMICOLON>
}

void MainDeclaration() #MainDeclaration: {}
{
    <STATIC> <VOID> <MAIN> <LPARENS> <STRING> <LSQPARENS> <RSQPARENS> <IDENTIFIER> <RPARENS>
    <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RBRACKET>
}

String Type() #void: {Token type; String sType;}
{
    (     <BOOLEAN> { sType="boolean"; }
        | <INT> { sType="int"; } 
            [<LSQPARENS> <RSQPARENS> { sType+="[]"; }]
        | <STRING> { sType="String"; }
        | type=<IDENTIFIER> { sType=type.image; }
    )
    { return sType; }
}

void Statement() #void: {}
{
      Scope()
    | IfStatement()
    | WhileStatement()
    | ( LOOKAHEAD(2) //Lookahead is used because Expression can also expand to an identifier
        EqualsStatement()
        | Expression() <SEMICOLON>
    )
}

void Scope() #Scope: {}
{
    <LBRACKET> (Statement())* <RBRACKET>
}

void EqualsStatement() #Equals(): {}
{
    ComplexIdentifier() <EQUALS> Expression() <SEMICOLON>
}

void IfStatement() #IF: {}
{
    <IF> <LPARENS> Expression() <RPARENS> Statement() <ELSE> Statement()
}

void WhileStatement() #While: {}
{
    try {
        <WHILE> <LPARENS> Expression() <RPARENS>
    }
    catch (ParseException e) {
        SkipTo(LBRACKET, "while statement");
    }
    Statement()
}

void Expression() #Expression: {}
{
    AndExpression()
}

void AndExpression() #void: {}
{
    LessExpression() [
        <AND> AndExpression() #And(2)
    ]
}

void LessExpression() #void: {}
{
    SumSubExpression() [
        <LESSTHAN> LessExpression() #LessThan(2)
    ]
}

void SumSubExpression() #void: {}
{
    MulDivExpression() [
          <PLUS>  SumSubExpression() #Plus(2)
        | <MINUS> SumSubExpression() #Minus(2)
    ]
}

void MulDivExpression() #void: {}
{
    NotExpression() [
          <TIMES>   MulDivExpression() #Times(2)
        | <DIVIDOR> MulDivExpression() #Dividor(2)
    ]
}

void NotExpression() #Not(addNot) : {boolean addNot=false;}
{
    [<NOT> {addNot=true;}] DotExpression()
}

void DotExpression() #void: {}
{
    ArrayAccess() [
        <DOT> (
              <LENGTH> #Length(1)
            // Function call has 3 children: class name, method name and arguments
            | FunctionCall() #FuncCall(3)
        )
    ]
}

void FunctionCall() #void: {}
{
    Identifier() <LPARENS> FunctionArguments() <RPARENS>
}


void FunctionArguments() #FuncArgs: {}
{
    [Expression() (<COMMA> Expression())* ]
}

void ArrayAccess() #void: {}
{
    Expression_LT() [<LSQPARENS> Expression() <RSQPARENS> #ArrayAccess(2)]
}

void Expression_LT() #void: {}
{
      Literal()
    | Identifier()
    | Expr_NEW()
    | <LPARENS> Expression() <RPARENS>
}

void Literal() #Literal: {Token literal;}
{
    (     literal=<INTEGER_LITERAL>
        | literal=<TRUE>
        | literal=<FALSE>
        | literal=<THIS>
    ) {jjtThis.literal = literal.image;}
}

void Expr_NEW() #New: {}
{
    <NEW> (
          <INT> <LSQPARENS> Expression() <RSQPARENS> {jjtThis.setType("int[]");}
        | Identifier() <LPARENS> <RPARENS> 
    )
}

void ComplexIdentifier() #void: {}
{
    Identifier() [ <LSQPARENS> Expression() <RSQPARENS> #ArrayAccess(2)]
}

void Identifier() #Identifier: {Token identifier;}
{
    identifier=<IDENTIFIER> {
        jjtThis.setIdentifier(identifier.image);
    }
}